Title: Other Elements

----

Text:

# Other Elements

## General Handling of svg.js elements

### Creating SVG Elements

In svg.js every element is an object which can be either created by constructing it:

```js
import { Rect } from "@svgdotjs/svg.js"
var rect = new Rect().size(100, 100).addTo(draw)
// or to reuse an existing node
var rect = new Rect(node).size(100, 100)
```

or by using a constructor method on a container:

```js
var rect = draw.rect(100, 100)
```


While the last example appends the constructed element directly to the container, it has to be done manually in the former example (`addTo`).
Constructing bare svg.js objects is therefore for fine control and most often not needed.

### Creating SVG Elements with Attributes

svg.js allows to change attributes either through the `attr()` method or by calling specialized methods like `move()`. However, it is often easier to pass in attributes directly on construction:

```js
var rect = new Rect({width: 100, height: 100}).addTo(draw)
// or
var rect = draw.rect({width: 100, height: 100})
```

This is a shorthand for calling `attr()` after construction.

<br>
# SVG.Dom

SVG.Dom is the base prototype for all dom elements created by svg.js. It offers simple dom functionality like `attr()` and is usuable with HTML elements.
For all elements that are not described by SVG.js, the `SVG.Dom` class come in handy, too.

## element() <span class="suffix">constructor</span>

`returns` __`SVG.Dom`__

The `SVG.Dom` class can be instantiated with the `element()` method on any element:

```javascript
var element = draw.element('title')
```

The string value passed as the first argument is the node name that should be generated.

Optionally attributes can be added directly by passing them as second argument:

```javascript
var element = draw.element('title', {id: 'myId'})
```

## <span class="subject">element.</span>words()

`returns` __`itself`__

The `SVG.Dom` instance carries an additional method to add plain text:

```javascript
var element = draw.element('title').words('This is a title.')
//-> <title>This is a title.</title>
```

<br>
# SVG.Rect

## rect() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Rect`__ ` which inherits from ` __`SVG.Shape`__

Rects have two arguments, their `width` and `height`:

```javascript
var rect = draw.rect(100, 100)
```

<iframe width="100%" height="205" src="//jsfiddle.net/Fuzzy/ekvx1p04/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## <span class="subject">rect.</span>radius()

`returns` __`itself`__<br>`animate` __`yes`__

Rects can also have rounded corners:

```javascript
rect.radius(10)
```

This will set the `rx` and `ry` attributes to `10`. To set `rx` and `ry` individually:

```javascript
rect.radius(10, 20)
```

<br>
# SVG.Circle

## circle() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Circle`__ ` which inherits from ` __`SVG.Shape`__

The only argument necessary for a circle is the diameter:

```javascript
var circle = draw.circle(100)
```

<iframe width="100%" height="205" src="//jsfiddle.net/Fuzzy/tkn3mg7z/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## <span class="subject">circle.</span>radius()

`returns` __`itself`__<br>`animate` __`yes`__

```javascript
circle.radius(75)
```

<br>
# SVG.Ellipse

## ellipse() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Circle`__ ` which inherits from ` __`SVG.Shape`__

Ellipses have two arguments, their `width` and `height`:

```javascript
var ellipse = draw.ellipse(200, 100)
```

<iframe width="100%" height="205" src="//jsfiddle.net/Fuzzy/1f0j4czx/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## <span class="subject">ellipse.</span>radius()

`returns` __`itself`__<br>`animate` __`yes`__

Ellipses can also be redefined by their radii:

```javascript
ellipse.radius(75, 50)
```

<br>
# SVG.Line

## line() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Line`__ ` which inherits from ` __`SVG.Shape`__

Create a line from point A to point B:

```javascript
var line = draw.line(0, 0, 100, 150).stroke({ width: 1 })
```

Creating a line element can be done in four ways. Look at the `plot()` method to see all the possibilities.

<iframe width="100%" height="205" src="//jsfiddle.net/Fuzzy/ve7frkxd/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## <span class="subject">line.</span>array()

`returns` __`SVG.PointArray`__

References the `SVG.PointArray` instance. This method is rather intended for internal use:

```javascript
polyline.array()
```

More info: (link: /classes/#svg-pointarray text: SVG.PointArray).

## <span class="subject">line.</span>plot()
 
`returns` __`itself`__<br>`animate` __`yes`__

Updating a line is done with the `plot()` method:

```javascript
line.plot(50, 30, 100, 150)
```

Alternatively it also accepts a point string:

```javascript
line.plot('0,0 100,150')
```

Or a point array:

```javascript
line.plot([[0, 0], [100, 150]])
```

Or an instance of `SVG.PointArray`:

```javascript
var array = new SVG.PointArray([[0, 0], [100, 150]])
line.plot(array)
```

The `plot()` method can also be animated:
```javascript
line.animate(3000).plot([[200, 200], [100, 150]])
```

<br>
# SVG.Polyline

## polyline() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Polyine`__ ` which inherits from ` __`SVG.Shape`__

The polyline element defines a set of connected straight line segments. Typically, polyline elements define open shapes:

```javascript
var polyline = draw.polyline('0,0 100,50 50,100').fill('none').stroke({ width: 1 })
```

Polyline strings consist of a list of points separated by commas or spaces. So `x,y x,y x,y` as well as `x y x y x y` or even `x,y,x,y,x,y` will work.

As an alternative, an array of points will work as well:

```javascript
var polyline = draw.polyline([[0,0], [100,50], [50,100]])
```

Or even a flat array of points that's preferred:

```javascript
var polyline = draw.polyline([0,0, 100,50, 50,100])
```

<iframe width="100%" height="205" src="//jsfiddle.net/Fuzzy/qhb6709u/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## <span class="subject">polyline.</span>array()

`returns` __`SVG.PointArray`__

References the `SVG.PointArray` instance. This method is rather intended for internal use:

```javascript
polyline.array()
```

More info: (link: /classes/#svg-pointarray text: SVG.PointArray).

## <span class="subject">polyline.</span>clear()

`returns` __`itself`__

When the given point data is parsed, the result is cached. This method clears the cache.

```js
polyline.clear()
```

## <span class="subject">polyline.</span>plot()

`returns` __`itself`__<br>`animate` __`yes`__

Polylines can be updated using the `plot()` method:

```javascript
polyline.plot([[0,0], [100,50], [50,100], [150,50], [200,50]])
```

The `plot()` method can also be animated:

```javascript
polyline.animate(3000).plot([[0,0], [100,50], [50,100], [150,50], [200,50], [250,100], [300,50], [350,50]])
```

<br>
# SVG.Polygon

## polygon() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Polygon`__ ` which inherits from ` __`SVG.Shape`__

The polygon element, unlike the polyline element, defines a closed shape consisting of a set of connected straight line segments:

```javascript
var polygon = draw.polygon('0,0 100,50 50,100').fill('none').stroke({ width: 1 })
```

Polygon strings or arrays are exactly the same as polyline strings. There is no need to close the shape as the first and last point will be connected automatically.

<iframe width="100%" height="205" src="//jsfiddle.net/Fuzzy/L9xpbz5w/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## <span class="subject">polygon.</span>array()

`returns` __`SVG.PointArray`__

References the `SVG.PointArray` instance. This method is rather intended for internal use:

```javascript
polygon.array()
```

More info: (link: /classes/#svg-pointarray text: SVG.PointArray).

## <span class="subject">polygon.</span>clear()

`returns` __`itself`__

When the given point data is parsed, the result is cached. This method clears the cache.

```js
polygon.clear()
```

## <span class="subject">polygon.</span>plot()

`returns` __`itself`__<br>`animate` __`yes`__

Like polylines, polygons can be updated using the `plot()` method:

```javascript
polygon.plot([[0,0], [100,50], [50,100], [150,50], [200,50]])
```

The `plot()` method can also be animated:

```javascript
polygon.animate(3000).plot([[0,0], [100,50], [50,100], [150,50], [200,50], [250,100], [300,50], [350,50]])
```

<br>
# SVG.Path

## path() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Path`__ ` which inherits from ` __`SVG.Shape`__

The path string is similar to the polygon string but much more complex in order to support curves:

```javascript
draw.path('M0 0 H50 A20 20 0 1 0 100 50 v25 C50 125 0 85 0 85 z')
```

<iframe width="100%" height="205" src="//jsfiddle.net/Fuzzy/8gq1ac6x/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

For more details on path data strings, please refer to the [SVG documentation on path data](http://www.w3.org/TR/SVG/paths.html#PathData).

## <span class="subject">path.</span>array()

`returns` __`SVG.PathArray`__

References the `SVG.PathArray` instance. This method is rather intended for internal use:

```javascript
path.array()
```

More info: (link: /classes/#svg-patharray text: SVG.PathArray).

## <span class="subject">path.</span>clear()

`returns` __`itself`__

When the given path data is parsed, the result is cached. This method clears the cache.

```js
path.clear()
```

## <span class="subject">path.</span>length()

`returns` __`number`__

Get the total length of a path element:

```javascript
var length = path.length()
```

## <span class="subject">path.</span>pointAt()

`returns` __`SVG.Point`__

Get point on a path at given length:

```javascript
var point = path.pointAt(105)
```

## <span class="subject">path.</span>plot()

`returns` __`itself`__<br>`animate` __`yes`__

Paths can be updated using the `plot()` method:

```javascript
path.plot('M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80')
```

The `plot()` method can also be animated:

```javascript
path.animate(2000).plot('M10 80 C 40 150, 65 150, 95 80 S 150 10, 180 80').loop(true, true)
```

There is only basic support for animating paths baked into SVG.js, which means that only paths with the same commands (`M`,`C`,`S` etc.) are animateable.

## <span class="subject">path.</span>text()

`returns` __`SVG.TextPath`__

Creating a text element with a textpath linked to the current path can be done with the `text()` method:

```javascript
var textpath = path.text('SVG.js rocks!')
```

<br>
# SVG.Text

## text() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Text`__ ` which inherits from ` __`SVG.Shape`__

Unlike html, text in svg is much harder to tame. There is no way to create flowing text, so newlines should be entered manually. In SVG.js there are two ways to create text elements.

The first and easiest method is to provide a string of text, split by newlines:

```javascript
var text = draw.text("Lorem ipsum dolor sit amet consectetur.\nCras sodales imperdiet auctor.")
```

This will automatically create a block of text and insert newlines where necessary.

The second method will give you much more control but requires a bit more code:

```javascript
var text = draw.text(function(add) {
  add.tspan('Lorem ipsum dolor sit amet ').newLine()
  add.tspan('consectetur').fill('#f06')
  add.tspan('.')
  add.tspan('Cras sodales imperdiet auctor.').newLine().dx(20)
  add.tspan('Nunc ultrices lectus at erat').newLine()
  add.tspan('dictum pharetra elementum ante').newLine()
})
```

As a more convinient syntax for newlines it is also possible to use the `newLine()` constructor instead of `tspan(...).newLine()`:

```javascript
var text = draw.text(function(add) {
  add.newLine('Same as')
  add.newLine('above').fill('#f06')
})
```

If you want to go the other way and don't want to add tspans at all, just one line of text, you can use the `plain()` method instead:

```javascript
var text = draw.plain('Lorem ipsum dolor sit amet consectetur.')
```

This is a shortcut to the `plain` method on the `SVG.Text` instance which doesn't render newlines at all.

<iframe width="100%" height="160" src="//jsfiddle.net/Fuzzy/rm1wjnft/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## <span class="subject">text.</span>amove()

`returns` __`itself`__

Unlike other elements, text is usually positioned accordining to its baseline and textanchor. Svg.js gives you the possibilitie to move every shape by its upper left corner.
However, sometimes it is needed to move text by baseline and anchor. This can be realized with `amove()`

```js
var text = draw.text('Some text for you')
text.amove(100, 50)
```

## <span class="subject">text.</span>ax() _as setter_

`returns` __`itself`__<br>`animate` __`yes`__

Move the element by its text anchor along the x-axis only:

```javascript
text.ax(200)
```

## <span class="subject">text.</span>ax() _as getter_

`returns` __`value`__

Without an argument the `ax()` method serves as a getter:

```javascript
var x = rect.ax()
```

## <span class="subject">text.</span>ay() _as setter_

`returns` __`itself`__<br>`animate` __`yes`__

Move the element by its baseline along the y-axis only:

```javascript
text.ay(200)
```

## <span class="subject">text.</span>ay() _as getter_

`returns` __`value`__

Without an argument the `ax()` method serves as a getter:

```javascript
var x = rect.ay()
```

## <span class="subject">text.</span>build()

`returns` __`itself`__

The `build()` can be used to enable / disable build mode. With build mode disabled, the `plain()` and `tspan()` methods will first call the `clear()` method before adding the new content. So when build mode is enabled, `plain()` and `tspan()` will append the new content to the existing content. When passing a block to the `text()` method, build mode is toggled automatically before and after the block is called. But in some cases it might be useful to be able to toggle it manually:

```javascript
var text = draw.text('This is just the start, ')

text.build(true)  // enables build mode

var tspan = text.tspan('something pink in the middle ').fill('#00ff97')
text.plain('and again boring at the end.')

text.build(false) // disables build mode

tspan.animate('2s').fill('#f06')
```

## <span class="subject">text.</span>clear()

`returns` __`itself`__

Clear all the contents of the called text element:

```javascript
text.clear()
```

## <span class="subject">text.</span>length()

`returns` __`number`__

Gets the total computed text length of all tspans together:

```javascript
text.length()
```

## <span class="subject">text.</span>font() _as setter_

`returns` __`itself`__

A convenience method to add font-related properties:

```javascript
text.font({
  family:   'Helvetica'
, size:     144
, anchor:   'middle'
, leading:  '1.5em'
})
```

Not unlike the `attr()` method, the `font()` method also accepts a key/value pair:

```javascript
text.font('family', 'Menlo')
```

Available properties are:
- `leading` (will do the same as calling the `leading()` method as setter)
- `anchor` (will set the `text-anchor` attribute)
- `family` (will set the `font-family` attribute)
- `size` (will set the `font-size` attribute)
- `stretch` (will set the `font-stretch` attribute)
- `style` (will set the `font-style` attribute)
- `variant` (will set the `font-variant` attribute)
- `weight` (will set the `font-weight` attribute)

Any other property will be applied as given. So, for example, the `letter-spacing` property will just be applied as it would be given to the `attr()` method. More on (link: https://www.w3.org/TR/SVG/text.html#FontPropertiesUsedBySVG text: font-related properties here target: _blank).

## <span class="subject">text.</span>font() _as getter_

As you might expect, the `font()` method also acts as a getter:

```javascript
var leading = text.font('leading')
```

## <span class="subject">text.</span>leading() _as setter_

`returns` __`itself`__<br>`animate` __`yes`__

As opposed to html, where leading is defined by `line-height`, svg does not have a natural leading equivalent. In svg, lines are not defined naturally. They are defined by `<tspan>` nodes with a `dy` attribute defining the line height and an `x` value resetting the line to the `x` position of the parent text element. But you can also have many nodes in one line defining a different `y`, `dy`, `x` or even `dx` value. This gives us a lot of freedom, but also a lot more responsibility. We have to decide when a new line is defined, where it starts, what its offset is and what it's height is. The `leading()` method in SVG.js tries to ease the pain by giving you behaviour that is much closer to html. In combination with newline separated text, it works just like html:

```javascript
var text = draw.text("Lorem ipsum dolor sit amet consectetur.\nCras sodales imperdiet auctor.")
text.leading(1.3)
```

This will render a text element with a tspan element for each line, with a `dy` value of `130%` of the font size.

Note that the `leading()` method assumes that every first level tspan in a text node represents a new line. Using `leading()` on text elements containing multiple tspans in one line (e.g. without a wrapping tspan defining a new line) will render scrambled. So it is advisable to use this method with care, preferably only when throwing newline separated text at the text element or calling the `newLine()` method on every first level tspan added in the block passed as an argument to the text element.

## <span class="subject">text.</span>leading() _as getter_

`returns` __`value`__

Get the current leading value:

```javascript
var leading = text.leading()
```

## <span class="subject">text.</span>path()

`returns` __`SVG.TextPath`__

Creates a textPath in a text element and returns the textPath:

```javascript
var text = draw.text(function(add) {
  add.tspan('We go ')
  add.tspan('up').fill('#f09').dy(-40)
  add.tspan(', then we go down, then up again').dy(40)
})

var path = 'M 100 200 C 200 100 300 0 400 100 C 500 200 600 300 700 200 C 800 100 900 100 900 100'

var textpath = text.path(path).font({ size: 42.5, family: 'Verdana' })
```

## <span class="subject">text.</span>textPath()

To get the textpath in a text use `textPath()`:

```javascript
var textpath = text.textPath().attr('startOffset', '50%')
```

## <span class="subject">text.</span>plain()

`returns` __`itself`__

If the content of the element doesn't need any styling or multiple lines, it might be sufficient to just add some plain text:

```javascript
text.plain('I do not have any expectations.')
```

## <span class="subject">text.</span>rebuild()

`returns` __`itself`__

This is an internal callback that probably never needs to be called manually. Basically it rebuilds the text element whenerver `font-size` and `x` attributes or the `leading()` of the text element are modified. This method also acts a setter to enable or disable rebuilding:

```javascript
text.rebuild(false) //-> disables rebuilding
text.rebuild(true)  //-> enables rebuilding and instantaneously rebuilds the text element
```

## <span class="subject">text.</span>text() _as setter_

`returns` __`itself`__

Changing text afterwards is also possible with the `text()` method:

```javascript
text.text('Brilliant!')
```

## <span class="subject">text.</span>text() _as getter_

`returns` __`string`__

To get the raw text content:

```javascript
text.text()
```

## <span class="subject">text.</span>tspan()

`returns` __`SVG.Tspan`__

Just adding one tspan is also possible:

```javascript
text.tspan(' on a train...').fill('#f06')
```

<br>
# SVG.TextPath

## textPath() <span class="suffix">constructor for textPath</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.TextPath`__ ` which inherits from ` __`SVG.Text`__

To construct a text along a path, the `textPath()` constructor can be used:

```javascript
var textpath = draw.textPath('Some Text along a path', 'M 100 200 C 200 100 300 0 400 100 C 500 200 600 300 700 200 C 800 100 900 100 900 100')
```

**Note**: If a `startOffset` other than a percentage is given, then the value represents a distance along the path measured in the current user coordinate system.

<iframe width="100%" height="400" src="//jsfiddle.net/Fuzzy/f2wbgx5a/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## <span class="subject">textPath.</span>array()

`returns` __`SVG.PathArray`__

Get the path array of the underlying path:

```javascript
var array = textpath.array()
```

## <span class="subject">textPath.</span>plot()

`returns` __`itself`__<br>`animate` __`yes`__

Change the path on the textpath element:

```javascript
text.textPath().plot('M 300 500 C 200 100 300 0 400 100 C 500 200 600 300 700 200')
```

## <span class="subject">textPath.</span>textPath()

`returns` __`SVG.TextPath`__

Referencing the textPath node directly:

```javascript
var textPath = text.textPath()
```

## <span class="subject">textPath.</span>track()

`returns` __`SVG.Path`__

Referencing the linked path element directly:

```javascript
var path = textpath.track()
```

<br>
**Note**: `SVG.TextPath` inherits from `SVG.Text`, so all those methods are inherited as well.

## Events for SVG.Text
The text element has one event. It is fired every time the `rebuild()` method is called:

```javascript
text.on('rebuild', function() {
  // whatever you need to do after rebuilding
})
```

<br>
# SVG.Tspan

## tspan() <span class="suffix">constructor</span>

`constructor on` __`SVG.Text`__
`returns` __`SVG.Tspan`__ ` which inherits from ` __`SVG.Shape`__

The tspan elements are only available inside text elements or inside other tspan elements.

```javascript
text.tspan('spannened')
```

## <span class="subject">tspan.</span>clear()

`returns` __`itself`__

Clear all the contents of the called tspan element:

```javascript
tspan.clear()
```

## <span class="subject">tspan.</span>dx()

`returns` __`itself`__<br>`animate` __`yes`__

Define the dynamic `x` value of the element, much like a html element with `position:relative` and `left` defined:

```javascript
tspan.dx(30)
```

## <span class="subject">tspan.</span>dy()

`returns` __`itself`__<br>`animate` __`yes`__

Define the dynamic `y` value of the element, much like a html element with `position:relative` and `top` defined:

```javascript
tspan.dy(30)
```

## <span class="subject">tspan.</span>plain()

`returns` __`itself`__

Just adds some plain text:

```javascript
tspan.plain('I do not have any expectations.')
```

## <span class="subject">tspan.</span>length()

`returns` __`number`__

Gets the total computed text length:

```javascript
tspan.length()
```

## <span class="subject">tspan.</span>newLine()

`returns` __`itself`__

The `newLine()` is a convenience method for adding a new line with a `dy` attribute using the current "leading":

```javascript
var text = draw.text(function(add) {
  add.tspan('Lorem ipsum dolor sit amet ').newLine()
  add.tspan('consectetur').fill('#f06')
  add.tspan('.')
  add.tspan('Cras sodales imperdiet auctor.').newLine().dx(20)
  add.tspan('Nunc ultrices lectus at erat').newLine()
  add.tspan('dictum pharetra elementum ante').newLine()
})
```

## <span class="subject">tspan.</span>text()

`returns` __`itself`__

Update the content of the tspan. This can be done by either passing a string:

```javascript
tspan.text('Just a string.')
```

Which will basicly call the `plain()` method:

Or by passing a block to add more specific content inside the called tspan:

```javascript
tspan.text(function(add) {
  add.plain('Just plain text.')
  add.tspan('Fancy text wrapped in a tspan.').fill('#f06')
  add.tspan(function(addMore) {
    addMore.tspan('And you can doo deeper and deeper...')
  })
})
```

## <span class="subject">tspan.</span>tspan()

`returns` __`SVG.Tspan`__

Add a nested tspan:

```javascript
tspan.tspan('I am a child of my parent').fill('#f06')
```

## <span class="subject">tspan.</span>amove()

See [`Text.amove()`](#text-amove)

<br>
# SVG.Image

## image() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Image`__ ` which inherits from ` __`SVG.Shape`__

Creating images is as you might expect:

```javascript
var image = draw.image('/path/to/image.jpg')
```

If you want to execute a callback once the image is loaded, you can pass a function as additional parameter:

```javascript
var image = draw.image('/path/to/image.jpg', function (event) {
  // image loaded
  // this is the loading event for the underlying img element
  // you can access the natural width and height of the image with
  // event.target.naturalWidth, event.target.naturalHeight
})
```

<iframe width="100%" height="205" src="//jsfiddle.net/Fuzzy/pqhdw9nj/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## <span class="subject">image.</span>load()

`returns` __`itself`__

Loading another image can be done with the `load()` method:

```javascript
image.load('/path/to/another/image.jpg', callback)
```

## Image events

You can bind to the `load` and `error` event when loading an image.
This can be done as always with `on`:

```javascript
image.on('load', function (e) {
  // this is the loading event for the svg image
})
```

<br>
# SVG.Gradient

## gradient() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Gradient`__ ` which inherits from ` __`SVG.Container`__

There are `linear` and `radial` gradients. The `linear` gradient can be created like this:

```javascript
var gradient = draw.gradient('linear', function(add) {
  add.stop(0, '#333')
  add.stop(1, '#fff')
})
```

Finally, to use the gradient on an element:

```javascript
rect.attr({ fill: gradient })
```

Or:

```javascript
rect.fill(gradient)
```

<iframe width="100%" height="205" src="//jsfiddle.net/Fuzzy/1csekyfr/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

(link:https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Gradients text: MDN target: _blank) has a great example page on how SVG Gradients work.

## <span class="subject">gradient.</span>stop()

`returns` __`itself`__

The `offset` and `color` parameters are required for stops, `opacity` is optional. The offset is a float between `0` and `1`, or a percentage value (e.g. `33%`).

```javascript
gradient.stop(0, '#333')
```

or

```javascript
gradient.stop({ offset: 0, color: '#333', opacity: 1 })
```

## <span class="subject">gradient.</span>url()

`returns` __`string`__

```javascript
gradient.url() //-> returns 'url(#SvgjsGradient1234)'
```

## <span class="subject">gradient.</span>from()

`returns` __`itself`__<br>`animate` __`yes`__

To define the direction you can set from `x`, `y` and to `x`, `y`:

```javascript
gradient.from(0, 0).to(0, 1)
```

The from and to values are also expressed in percent.

## <span class="subject">gradient.</span>get()

`returns` __`SVG.Stop`__

The `get()` method makes it even easier to get a stop from an existing gradient:

```javascript
var gradient = draw.gradient('radial', function(add) {
  add.stop({ offset: 0, color: '#000', opacity: 1 })   // -> first
  add.stop({ offset: 0.5, color: '#f03', opacity: 1 }) // -> second
  add.stop({ offset: 1, color: '#066', opacity: 1 })   // -> third
})

var s1 = gradient.get(0) // -> returns "first" stop
```

## <span class="subject">gradient.</span>radius()

`returns` __`itself`__<br>`animate` __`yes`__

Radial gradients have a `radius()` method to define the outermost radius to where the inner color should develop:

```javascript
var gradient = draw.gradient('radial', function(add) {
  add.stop(0, '#333')
  add.stop(1, '#fff')
})

gradient.from(0.5, 0.5).to(0.5, 0.5).radius(0.5)
```

## <span class="subject">gradient.</span>to()

`returns` __`itself`__<br>`animate` __`yes`__

To define the direction you can set from `x`, `y` and to `x`, `y`:

```javascript
gradient.from(0, 0).to(0, 1)
```

The from and to values are also expressed in percent.

## <span class="subject">gradient.</span>update()

`returns` __`itself`__

A gradient can also be updated afterwards:

```javascript
gradient.update(function(add) {
  add.stop(0.1, '#333', 0.2)
  add.stop(0.9, '#f03', 1)
})
```

And even a single stop can be updated:

```javascript
var s1, s2, s3

draw.gradient('radial', function(add) {
  s1 = add.stop(0, '#000')
  s2 = add.stop(0.5, '#f03')
  s3 = add.stop(1, '#066')
})

s1.update(0.1, '#0f0', 1)
```

<br>
# SVG.Stop

## at() <span class="suffix">constructor</span>

`constructor on` __`SVG.Gradient`__
`returns` __`SVG.Stop`__ ` which inherits from ` __`SVG.Element`__

The stop elements are only available inside gradient elements.

```javascript
var stop = gradient.stop(0.5, '#f03')
```

or

```javascript
var stop = gradient.stop({ offset: 0.5, color: '#f06', opacity: 1 })
```

## <span class="subject">stop.</span>update()

`returns` __`itself`__

Takes the same parameters as the constructor.

```javascript
stop.update(0, '#333')
```

or

```javascript
stop.update({ offset: 0, color: '#333', opacity: 1 })
```

<br>
# SVG.Pattern

## pattern() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Pattern`__ ` which inherits from ` __`SVG.Container`__

Creating a pattern is very similar to creating gradients:

```javascript
var pattern = draw.pattern(20, 20, function(add) {
  add.rect(20,20).fill('#f06')
  add.rect(10,10)
  add.rect(10,10).move(10,10)
})
```

This creates a checkered pattern of 20 x 20 pixels. You can add any available element to your pattern.

Finally, to use the pattern on an element:

```javascript
rect.attr({ fill: pattern })
```

Or:

```javascript
rect.fill(pattern)
```

<iframe width="100%" height="205" src="//jsfiddle.net/Fuzzy/b7s2wvjh/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## <span class="subject">pattern.</span>url()

`returns` __`string`__

```javascript
pattern.url() //-> returns 'url(#SvgjsPattern1234)'
```

## <span class="subject">pattern.</span>update()

`returns` __`itself`__

A pattern can also be updated afterwards:

```javascript
pattern.update(function(add) {
  add.circle(15).center(10,10)
})
```

<br>
# SVG.Mask

## mask() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Mask`__ ` which inherits from ` __`SVG.Container`__

```javascript
var ellipse = draw.ellipse(80, 40).move(10, 10).fill('#fff')

var mask = draw.mask().add(ellipse)

rect.maskWith(mask)
```

But you can also use multiple elements:

```javascript
var ellipse = draw.ellipse(80, 40).move(10, 10).fill({ color: '#fff' })
var text = draw.text('SVG.JS').move(10, 10).font({ size: 36 }).fill({ color: '#fff' })

var mask = draw.mask().add(text).add(ellipse)

rect.maskWith(mask)
```

<iframe width="100%" height="205" src="//jsfiddle.net/Fuzzy/kxqdnL7p/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## maskWith()

`constructor on` __`SVG.Element`__
`returns` __`itself`__

The easiest way to mask is to use a single element:

```javascript
var ellipse = draw.ellipse(80, 40).move(10, 10).fill({ color: '#fff' })

rect.maskWith(ellipse)
```

If you want the masked object to be rendered at 100% you need to set the fill color of the masking object to white. But you might also want to use a gradient:

```javascript
var gradient = draw.gradient('linear', function(add) {
  add.stop({ offset: 0, color: '#000' })
  add.stop({ offset: 1, color: '#fff' })
})

var ellipse = draw.ellipse(80, 40).move(10, 10).fill({ color: gradient })

rect.maskWith(ellipse)
```

## <span class="subject">mask.</span>unmask()

`returns` __`itself`__

Unmasking the elements can be done with the `unmask()` method:

```javascript
rect.unmask()
```

The `unmask()` method returns the masking element.

## <span class="subject">mask.</span>remove()

`returns` __`itself`__

Removing the mask altogether will also `unmask()` all masked elements as well:

```javascript
mask.remove()
```

## <span class="subject">element.</span>masker()

`returns` __`SVG.Mask`__

For your convenience, the masking element is also referenced in the masked element. This can be useful in case you want to change the mask:

```javascript
rect.masker().fill('#fff')
```

<br>
# SVG.ClipPath

Clipping elements works exactly the same as masking elements. The only difference is that clipped elements will adopt the geometry of the clipping element. Therefore events are only triggered when entering the clipping element whereas with masks the masked element triggers the event. Another difference is that masks can define opacity with their fill colour and clipPaths can't.

## clip() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.ClipPath`__ ` which inherits from ` __`SVG.Container`__

Clip with multiple elements:

```javascript
var ellipse = draw.ellipse(80, 40).move(10, 10)
var text = draw.text('SVG.JS').move(10, 10).font({ size: 36 })

var clip = draw.clip().add(text).add(ellipse)

rect.clipWith(clip)
```

<iframe width="100%" height="205" src="//jsfiddle.net/Fuzzy/twzrg5aq/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## clipWith()

`returns` __`itself`__

```javascript
var ellipse = draw.ellipse(80, 40).move(10, 10)

rect.clipWith(ellipse)
```

## <span class="subject">clipPath.</span>unclip()

`returns` __`itself`__

Unclipping the elements can be done with the `unclip()` method:

```javascript
rect.unclip()
```

## <span class="subject">clipPath.</span>remove()

`returns` __`itself`__

Removing the clip alltogether will also `unclip()` all clipped elements as well:

```javascript
clip.remove()
```

## <span class="subject">element.</span>clipper()

`returns` __`SVG.ClipPath`__

For your convenience, the clipping element is also referenced in the clipped element. This can be useful in case you want to change the clipPath:

```javascript
rect.clipper().move(10, 10)
```

<br>
# SVG.Use

## use() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Use`__ ` which inherits from ` __`SVG.Shape`__

The use element simply emulates another existing element. Any changes on the master element will be reflected on all the `use` instances. The usage of `use()` is very straightforward:

```javascript
var rect = draw.rect(100, 100).fill('#f09')
var use  = draw.use(rect).move(200, 200)
```

In the case of the example above two rects will appear on the svg drawing, the original and the `use` instance. In some cases, you might want to hide the original element. The best way to do this is to create the original element in the defs node:

```javascript
var rect = draw.defs().rect(100, 100).fill('#f09')
var use  = draw.use(rect).move(200, 200)
```

In this way, the rect element acts as a library element. You can edit it, but it won't be rendered.

Another way is to point an external SVG file, just specified the element `id` and path to file.

```javascript
var use  = draw.use('elementId', 'path/to/file.svg')
```

This way is useful when you have complex images already created.
Note that, for external images (outside your domain) it may be necessary to load the file with XHR.

<br>
# SVG.Marker

## marker() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Marker`__ ` which inherits from ` __`SVG.Container`__

Markers can be added to every individual point of a `line`, `polyline`, `polygon` and `path`. There are three types of markers: `start`, `mid` and `end`. Where `start` represents the first point, `end` the last and `mid` every point in between.

```javascript
var path = draw.path('M0 0 A50 50 0 0 1 50 50 A50 50 0 0 0 100 100')

path.fill('none').move(20, 20).stroke({ width: 1, color: '#ccc' })

path.marker('start', 10, 10, function(add) {
  add.circle(10).fill('#f06')
})
path.marker('mid', 10, 10, function(add) {
  add.rect(5, 10).cx(5).fill('#ccc')
})
path.marker('end', 20, 20, function(add) {
  add.circle(6).center(4, 5)
  add.circle(6).center(4, 15)
  add.circle(6).center(12, 10)

  this.fill('#0f9')
})
```

The `marker()` method can be used in three ways. Firstly, a marker can be created on any container element (e.g. svg, nested, group, ...). This is useful if you plan to reuse the marker many times, so it will create a marker in the defs but not show it yet:

```javascript
var marker = draw.marker(10, 10, function(add) {
  add.rect(10, 10)
})
```

Secondly a marker can be created and applied directly on its target element:

```javascript
path.marker('start', 10, 10, function(add) {
  add.circle(10).fill('#f06')
})
```

This will create a marker in the defs and apply it directly. Note that the first argument defines the position of the marker and that there are four arguments as opposed to three with the first example.

Lastly, if a marker is created for reuse on a container element, it can be applied directly to the target element:

```javascript
path.marker('mid', marker)
```

Finally, to get a marker instance from the target element reference:

```javascript
path.reference('marker-end')
```

<iframe width="100%" height="205" src="//jsfiddle.net/Fuzzy/rodu2qg0/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## <span class="subject">marker.</span>height()

`returns` __`itself`__<br>`animate` __`yes`__

Defines the `markerHeight` attribute:

```javascript
marker.height(10)
```

## <span class="subject">marker.</span>ref()

`returns` __`itself`__

By default, the `refX` and `refY` attributes of a marker are set to respectively half the `width` and `height` values. To define the `refX` and `refY` of a marker differently:

```javascript
marker.ref(2, 7)
```

## <span class="subject">marker.</span>size()

`returns` __`itself`__<br>`animate` __`yes`__

Defines the `markerWidth` and `markerHeight` attributes:

```javascript
marker.size(10, 10)
```

## <span class="subject">marker.</span>update()

`returns` __`itself`__

Updating the contents of a marker will `clear()` the existing content and add the content defined in the block passed as the first argument:

```javascript
marker.update(function(add) {
  add.circle(10)
})
```

## <span class="subject">marker.</span>width()

`returns` __`itself`__<br>`animate` __`yes`__

Defines the `markerWidth` attribute:

```javascript
marker.width(10)
```

## <span class="subject">marker.</span>orient()

`returns` __`itself`__<br>`animate` __`no`__

Defines the `orient` attribute:

```javascript
marker.orient(50)
```


<br>
# SVG.Style

The Style element creates a style-tag and adds rules for a selector

## style() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Style`__ ` which inherits from ` __`SVG.Element`__

```javascript
var style = draw.style('#myId', {color: 'blue'})
```

## fontface() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Style`__ ` which inherits from ` __`SVG.Element`__

```javascript
var style = draw.fontface('Arial', 'url', {...otherParameters})
```

## <span class="subject">style.</span>rule()

Adds another rule to the style tag:

```javascript
var style = draw.style('#myId', {color: 'blue'})
style.rule('.myClass', {fontSize: 16})
```

## <span class="subject">style.</span>font()

Adds another font to the style tag:

```javascript
var style = draw.style('#myId', {color: 'blue'})
style.font('Arial', 'url', {...otherParameters})
```

<br>
# SVG.ForeignObject

A foreign object can hold objects which are not from the svg namespace. Mostly this is HTML and is used together with SVG() to add html elements to it.

## foreignObject() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.ForeignObject`__ ` which inherits from ` __`SVG.Element`__

```javascript
var foreignObject = draw.foreignObject(width, height)
// Pass true as second parameter to SVG() to create an html in the html-namespace
foreignObject.add(SVG('<input type="text">', true))
```

----

Description: SVG.Element is the base prototype wrapping all elements (or nodes for that matter) in SVG.js. An extra level of refinement is added with SVG.Shape.
