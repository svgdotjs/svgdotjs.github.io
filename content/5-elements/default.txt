Title: Elements

----

Text: 

# Elements

`SVG.Element` is the base prototype wrapping all elements (or nodes for that matter) in SVG.js. An extra level of refinement is added with `SVG.Shape`. Every element that can take a `fill` and/or `stroke` attribute. It is preferred to extend elements with your own methods on `SVG.Shape`, rather than on `SVG.Element`.

<br>
# SVG.Rect

## rect() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Rect`__ ` which inherits from ` __`SVG.Shape`__

Rects have two arguments, their `width` and `height`:

```javascript
var rect = draw.rect(100, 100)
```

<iframe width="100%" height="205" src="//jsfiddle.net/wout/wmtt8rkz/7/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## <span class="subject">rect.</span>radius()

`returns` __`itself`__<br>`animate` __`yes`__

Rects can also have rounded corners:

```javascript
rect.radius(10)
```

This will set the `rx` and `ry` attributes to `10`. To set `rx` and `ry` individually:

```javascript
rect.radius(10, 20)
```

<br>
# SVG.Circle

## circle() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Circle`__ ` which inherits from ` __`SVG.Shape`__

The only argument necessary for a circle is the diameter:

```javascript
var circle = draw.circle(100)
```

<iframe width="100%" height="205" src="//jsfiddle.net/wout/79gmh7jf/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## <span class="subject">circle.</span>radius()

`returns` __`itself`__<br>`animate` __`yes`__

```javascript
circle.radius(75)
```

<br>
# SVG.Ellipse

## ellipse() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Circle`__ ` which inherits from ` __`SVG.Shape`__

Ellipses have two arguments, their `width` and `height`:

```javascript
var ellipse = draw.ellipse(200, 100)
```

<iframe width="100%" height="205" src="//jsfiddle.net/wout/mr7kjab1/1/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## <span class="subject">ellipse.</span>radius()

`returns` __`itself`__<br>`animate` __`yes`__

Ellipses can also be redefined by their radii:

```javascript
ellipse.radius(75, 50)
```

<br>
# SVG.Line

## line() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Line`__ ` which inherits from ` __`SVG.Shape`__

Create a line from point A to point B:

```javascript
var line = draw.line(0, 0, 100, 150).stroke({ width: 1 })
```

Creating a line element can be done in four ways. Look at the `plot()` method to see all the possibilities.

<iframe width="100%" height="205" src="//jsfiddle.net/wout/1z9LmLha/3/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## <span class="subject">line.</span>array()

`returns` __`SVG.PointArray`__

References the `SVG.PointArray` instance. This method is rather intended for internal use:

```javascript
polyline.array()
```

More info: (link: /classes/#svg-pointarray text: SVG.PointArray).

## <span class="subject">line.</span>plot()

`returns` __`itself`__<br>`animate` __`yes`__

Updating a line is done with the `plot()` method:

```javascript
line.plot(50, 30, 100, 150)
```

Alternatively it also accepts a point string:

```javascript
line.plot('0,0 100,150')
```

Or a point array:

```javascript
line.plot([[0, 0], [100, 150]])
```

Or an instance of `SVG.PointArray`:

```javascript
var array = new SVG.PointArray([[0, 0], [100, 150]])
line.plot(array)
```

The `plot()` method can also be animated:
```javascript
line.animate(3000).plot([[200, 200], [100, 150]])
```

<br>
# SVG.Polyline

## polyline() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Polyine`__ ` which inherits from ` __`SVG.Shape`__

The polyline element defines a set of connected straight line segments. Typically, polyline elements define open shapes:

```javascript
var polyline = draw.polyline('0,0 100,50 50,100').fill('none').stroke({ width: 1 })
```

Polyline strings consist of a list of points separated by comma's or spaces. So `x,y x,y x,y` as well as `x y x y x y` or even `x,y,x,y,x,y` will work.

As an alternative, an array of points will work as well:

```javascript
var polyline = draw.polyline([[0,0], [100,50], [50,100]])
```

Or even a flat array of points that's preferred:

```javascript
var polyline = draw.polyline([0,0, 100,50, 50,100])
```

<iframe width="100%" height="205" src="//jsfiddle.net/wout/6wt24q7p/2/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## <span class="subject">polyline.</span>array()

`returns` __`SVG.PointArray`__

References the `SVG.PointArray` instance. This method is rather intended for internal use:

```javascript
polyline.array()
```

More info: (link: /classes/#svg-pointarray text: SVG.PointArray).

## <span class="subject">polyline.</span>clear()

`returns` __`itself`__

When the given point data is parsed, the result is cached. This method clears the cache.

```js
polyline.clear()
```

## <span class="subject">polyline.</span>plot()

`returns` __`itself`__<br>`animate` __`yes`__

Polylines can be updated using the `plot()` method:

```javascript
polyline.plot([[0,0], [100,50], [50,100], [150,50], [200,50]])
```

The `plot()` method can also be animated:

```javascript
polyline.animate(3000).plot([[0,0], [100,50], [50,100], [150,50], [200,50], [250,100], [300,50], [350,50]])
```

<br>
# SVG.Polygon

## polygon() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Polygon`__ ` which inherits from ` __`SVG.Shape`__

The polygon element, unlike the polyline element, defines a closed shape consisting of a set of connected straight line segments:

```javascript
var polygon = draw.polygon('0,0 100,50 50,100').fill('none').stroke({ width: 1 })
```

Polygon strings or arrays are exactly the same as polyline strings. There is no need to close the shape as the first and last point will be connected automatically.

<iframe width="100%" height="205" src="//jsfiddle.net/wout/4aqnwLy0/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## <span class="subject">polygon.</span>array()

`returns` __`SVG.PointArray`__

References the `SVG.PointArray` instance. This method is rather intended for internal use:

```javascript
polygon.array()
```

More info: (link: /classes/#svg-pointarray text: SVG.PointArray).

## <span class="subject">polygon.</span>clear()

`returns` __`itself`__

When the given point data is parsed, the result is cached. This method clears the cache.

```js
polygon.clear()
```

## <span class="subject">polygon.</span>plot()

`returns` __`itself`__<br>`animate` __`yes`__

Like polylines, polygons can be updated using the `plot()` method:

```javascript
polygon.plot([[0,0], [100,50], [50,100], [150,50], [200,50]])
```

The `plot()` method can also be animated:

```javascript
polygon.animate(3000).plot([[0,0], [100,50], [50,100], [150,50], [200,50], [250,100], [300,50], [350,50]])
```

<br>
# SVG.Path

## path() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Path`__ ` which inherits from ` __`SVG.Shape`__

The path string is similar to the polygon string but much more complex in order to support curves:

```javascript
draw.path('M0 0 H50 A20 20 0 1 0 100 50 v25 C50 125 0 85 0 85 z')
```

<iframe width="100%" height="205" src="//jsfiddle.net/wout/oxaxp55z/2/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

For more details on path data strings, please refer to the [SVG documentation on path data](http://www.w3.org/TR/SVG/paths.html#PathData).

## <span class="subject">path.</span>array()

`returns` __`SVG.PathArray`__

References the `SVG.PathArray` instance. This method is rather intended for internal use:

```javascript
path.array()
```

More info: (link: /classes/#svg-patharray text: SVG.PathArray).

## <span class="subject">path.</span>clear()

`returns` __`itself`__

When the given path data is parsed, the result is cached. This method clears the cache.

```js
path.clear()
```

## <span class="subject">path.</span>length()

`returns` __`number`__

Get the total length of a path element:

```javascript
var length = path.length()
```

## <span class="subject">path.</span>pointAt()

`returns` __`object`__

Get point on a path at given length:

```javascript
var point = path.pointAt(105) //-> returns { x : 96.88497924804688, y : 58.062747955322266 }
```

## <span class="subject">path.</span>plot()

`returns` __`itself`__<br>`animate` __`yes`__

Paths can be updated using the `plot()` method:

```javascript
path.plot('M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80')
```

The `plot()` method can also be animated:

```javascript
path.animate(2000).plot('M10 80 C 40 150, 65 150, 95 80 S 150 10, 180 80').loop(true, true)
```

There is only basic support for animating paths baked into SVG.js, which means that only paths with the same commands (`M`,`C`,`S` etc.) are animateable.

If you need to animate paths that do not share the same commands in order, you can use [svg.pathmorphing.js](https://github.com/Fuzzyma/svg.pathmorphing.js)

<br>
# SVG.Text

## text() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Text`__ ` which inherits from ` __`SVG.Shape`__

Unlike html, text in svg is much harder to tame. There is no way to create flowing text, so newlines should be entered manually. In SVG.js there are two ways to create text elements.

The first and easiest method is to provide a string of text, split by newlines:

```javascript
var text = draw.text("Lorem ipsum dolor sit amet consectetur.\nCras sodales imperdiet auctor.")
```

This will automatically create a block of text and insert newlines where necessary.

The second method will give you much more control but requires a bit more code:

```javascript
var text = draw.text(function(add) {
  add.tspan('Lorem ipsum dolor sit amet ').newLine()
  add.tspan('consectetur').fill('#f06')
  add.tspan('.')
  add.tspan('Cras sodales imperdiet auctor.').newLine().dx(20)
  add.tspan('Nunc ultrices lectus at erat').newLine()
  add.tspan('dictum pharetra elementum ante').newLine()
})
```

If you want to go the other way and don't want to add tspans at all, just one line of text, you can use the `plain()` method instead:

```javascript
var text = draw.plain('Lorem ipsum dolor sit amet consectetur.')
```

This is a shortcut to the `plain` method on the `SVG.Text` instance which doesn't render newlines at all.

<iframe width="100%" height="160" src="//jsfiddle.net/wout/7pdww24q/5/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## <span class="subject">text.</span>build()

`returns` __`itself`__

The `build()` can be used to enable / disable build mode. With build mode disabled, the `plain()` and `tspan()` methods will first call the `clear()` method before adding the new content. So when build mode is enabled, `plain()` and `tspan()` will append the new content to the existing content. When passing a block to the `text()` method, build mode is toggled automatically before and after the block is called. But in some cases it might be useful to be able to toggle it manually:

```javascript
var text = draw.text('This is just the start, ')

text.build(true)  // enables build mode

var tspan = text.tspan('something pink in the middle ').fill('#00ff97')
text.plain('and again boring at the end.')

text.build(false) // disables build mode

tspan.animate('2s').fill('#f06')
```

## <span class="subject">text.</span>clear()

`returns` __`itself`__

Clear all the contents of the called text element:

```javascript
text.clear()
```

## <span class="subject">text.</span>length()

`returns` __`number`__

Gets the total computed text length of all tspans together:

```javascript
text.length()
```

## <span class="subject">text.</span>font() _as setter_

`returns` __`itself`__

A convenience method to add font-related properties:

```javascript
text.font({
  family:   'Helvetica'
, size:     144
, anchor:   'middle'
, leading:  '1.5em'
})
```

Not unlike the `attr()` method, the `font()` method also accepts a key/value pair:

```javascript
text.font('family', 'Menlo')
```

Available properties are:
- `leading` (will do the same as calling the `leading()` method as setter)
- `anchor` (will set the `text-anchor` attribute)
- `family` (will set the `font-family` attribute)
- `size` (will set the `font-size` attribute)
- `stretch` (will set the `font-stretch` attribute)
- `style` (will set the `font-style` attribute)
- `variant` (will set the `font-variant` attribute)
- `weight` (will set the `font-weight` attribute)

Any other property will be applied as given. So, for example, the `letter-spacing` property will just be applied as it would be given to the `attr()` method. More on (link: https://www.w3.org/TR/SVG/text.html#FontPropertiesUsedBySVG text: font-related properties here target: _blank).

## <span class="subject">text.</span>font() _as getter_

As you might expect, the `font()` method also acts as a getter:

```javascript
var leading = text.font('leading')
```

## <span class="subject">text.</span>leading() _as setter_

`returns` __`itself`__<br>`animate` __`yes`__

As opposed to html, where leading is defined by `line-height`, svg does not have a natural leading equivalent. In svg, lines are not defined naturally. They are defined by `<tspan>` nodes with a `dy` attribute defining the line height and an `x` value resetting the line to the `x` position of the parent text element. But you can also have many nodes in one line defining a different `y`, `dy`, `x` or even `dx` value. This gives us a lot of freedom, but also a lot more responsibility. We have to decide when a new line is defined, where it starts, what its offset is and what it's height is. The `leading()` method in SVG.js tries to ease the pain by giving you behaviour that is much closer to html. In combination with newline separated text, it works just like html:

```javascript
var text = draw.text("Lorem ipsum dolor sit amet consectetur.\nCras sodales imperdiet auctor.")
text.leading(1.3)
```

This will render a text element with a tspan element for each line, with a `dy` value of `130%` of the font size.

Note that the `leading()` method assumes that every first level tspan in a text node represents a new line. Using `leading()` on text elements containing multiple tspans in one line (e.g. without a wrapping tspan defining a new line) will render scrambled. So it is advisable to use this method with care, preferably only when throwing newline separated text at the text element or calling the `newLine()` method on every first level tspan added in the block passed as an argument to the text element.

## <span class="subject">text.</span>leading() _as getter_

`returns` __`value`__

Get the current leading value:

```javascript
var leading = text.leading()
```

## <span class="subject">text.</span>lines()

`returns` __`SVG.Set`__

All first level tspans can be referenced with the `lines()` method:

```javascript
text.lines()
```

This will return an instance of `SVG.Set` including all `tspan` elements.

## <span class="subject">text.</span>plain()

`returns` __`itself`__

If the content of the element doesn't need any styling or multiple lines, it might be sufficient to just add some plain text:

```javascript
text.plain('I do not have any expectations.')
```

## <span class="subject">text.</span>rebuild()

`returns` __`itself`__

This is an internal callback that probably never needs to be called manually. Basically it rebuilds the text element whenerver `font-size` and `x` attributes or the `leading()` of the text element are modified. This method also acts a setter to enable or disable rebuilding:

```javascript
text.rebuild(false) //-> disables rebuilding
text.rebuild(true)  //-> enables rebuilding and instantaneously rebuilds the text element
```

## <span class="subject">text.</span>text() _as setter_

`returns` __`itself`__

Changing text afterwards is also possible with the `text()` method:

```javascript
text.text('Brilliant!')
```

## <span class="subject">text.</span>text() _as getter_

`returns` __`string`__

To get the raw text content:

```javascript
text.text()
```

## <span class="subject">text.</span>tspan()

`returns` __`SVG.Tspan`__

Just adding one tspan is also possible:

```javascript
text.tspan(' on a train...').fill('#f06')
```

<br>
# SVG.TextPath

## path() <span class="suffix">constructor for textPath</span>

`constructor on` __`SVG.Text`__
`returns` __`SVG.TextPath`__ ` which inherits from ` __`SVG.Text`__

A nice feature in svg is the ability to run text along a path:

```javascript
var text = draw.text(function(add) {
  add.tspan('We go ')
  add.tspan('up').fill('#f09').dy(-40)
  add.tspan(', then we go down, then up again').dy(40)
})

var path = 'M 100 200 C 200 100 300 0 400 100 C 500 200 600 300 700 200 C 800 100 900 100 900 100'

text.path(path).font({ size: 42.5, family: 'Verdana' })
```

When calling the `path()` method on a text element, the text element is mutated into an intermediate between a text and a path element. From that point on the text element will also feature a `plot()` method to update the path:

```javascript
text.plot('M 300 500 C 200 100 300 0 400 100 C 500 200 600 300 700 200 C 800 100 900 100 900 100')
```

Attributes specific to the `<textPath>` element can be applied to the textPath instance itself:

```javascript
text.textPath().attr('startOffset', '50%')
```

And they can be animated as well of course:

```javascript
text.textPath().animate(3000).attr('startOffset', '80%')
```

**Note**: If a `startOffset` other than a percentage is given, then the value represents a distance along the path measured in the current user coordinate system.

<iframe width="100%" height="400" src="//jsfiddle.net/wout/7wL1uv8n/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## <span class="subject">textPath.</span>array()

`returns` __`SVG.PathArray`__

Get the path array of the underlying path:

```javascript
var array = text.textPath().array()
```

## <span class="subject">textPath.</span>plot()

`returns` __`itself`__<br>`animate` __`yes`__

Change the path on the textpath element:

```javascript
text.textPath().plot('M 300 500 C 200 100 300 0 400 100 C 500 200 600 300 700 200')
```

## <span class="subject">textPath.</span>textPath()

`returns` __`SVG.TextPath`__

Referencing the textPath node directly:

```javascript
var textPath = text.textPath()
```

## <span class="subject">textPath.</span>track()

`returns` __`SVG.Path`__

Referencing the linked path element directly:

```javascript
var path = text.track()
```

<br>
**Note**: `SVG.TextPath` inherits from `SVG.Text`, so all those methods are inherited as well.

## Events for SVG.Text
The text element has one event. It is fired every time the `rebuild()` method is called:

```javascript
text.on('rebuild', function() {
  // whatever you need to do after rebuilding
})
```

<br>
# SVG.Tspan

## tspan() <span class="suffix">constructor</span>

`constructor on` __`SVG.Text`__
`returns` __`SVG.Tspan`__ ` which inherits from ` __`SVG.Shape`__

The tspan elements are only available inside text elements or inside other tspan elements.

```javascript
text.tspan('spannened')
```

## <span class="subject">tspan.</span>clear()

`returns` __`itself`__

Clear all the contents of the called tspan element:

```javascript
tspan.clear()
```

## <span class="subject">tspan.</span>dx()

`returns` __`itself`__<br>`animate` __`yes`__

Define the dynamic `x` value of the element, much like a html element with `position:relative` and `left` defined:

```javascript
tspan.dx(30)
```

## <span class="subject">tspan.</span>dy()

`returns` __`itself`__<br>`animate` __`yes`__

Define the dynamic `y` value of the element, much like a html element with `position:relative` and `top` defined:

```javascript
tspan.dy(30)
```

## <span class="subject">tspan.</span>plain()

`returns` __`itself`__

Just adds some plain text:

```javascript
tspan.plain('I do not have any expectations.')
```

## <span class="subject">tspan.</span>length()

`returns` __`number`__

Gets the total computed text length:

```javascript
tspan.length()
```

## <span class="subject">tspan.</span>newLine()

`returns` __`itself`__

The `newLine()` is a convenience method for adding a new line with a `dy` attribute using the current "leading":

```javascript
var text = draw.text(function(add) {
  add.tspan('Lorem ipsum dolor sit amet ').newLine()
  add.tspan('consectetur').fill('#f06')
  add.tspan('.')
  add.tspan('Cras sodales imperdiet auctor.').newLine().dx(20)
  add.tspan('Nunc ultrices lectus at erat').newLine()
  add.tspan('dictum pharetra elementum ante').newLine()
})
```

## <span class="subject">tspan.</span>text()

`returns` __`itself`__

Update the content of the tspan. This can be done by either passing a string:

```javascript
tspan.text('Just a string.')
```

Which will basicly call the `plain()` method:

Or by passing a block to add more specific content inside the called tspan:

```javascript
tspan.text(function(add) {
  add.plain('Just plain text.')
  add.tspan('Fancy text wrapped in a tspan.').fill('#f06')
  add.tspan(function(addMore) {
    addMore.tspan('And you can doo deeper and deeper...')
  })
})
```

## <span class="subject">tspan.</span>tspan()

`returns` __`SVG.Tspan`__

Add a nested tspan:

```javascript
tspan.tspan('I am a child of my parent').fill('#f06')
```

<br>
# SVG.Image

## image() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Image`__ ` which inherits from ` __`SVG.Shape`__

Creating images is as you might expect:

```javascript
var image = draw.image('/path/to/image.jpg')
```

If you know the size of the image, those parameters can be passed as the second and third arguments:

```javascript
var image = draw.image('/path/to/image.jpg', 200, 300)
```

<iframe width="100%" height="205" src="//jsfiddle.net/wout/dszxekge/1/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## <span class="subject">image.</span>load()

`returns` __`itself`__

Loading another image can be done with the `load()` method:

```javascript
image.load('/path/to/another/image.jpg')
```

## <span class="subject">image.</span>loaded()

`returns` __`itself`__

If you don't know the size of the image, obviously you will have to wait for the image to be `loaded`:

```javascript
var image = draw.image('/path/to/image.jpg').loaded(function(loader) {
  this.size(loader.width, loader.height)
})
```

The returned `loader` object as first the argument of the loaded method contains four values:
- `width`
- `height`
- `ratio` (width / height)
- `url`

<br>
# SVG.Gradient

## gradient() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Gradient`__ ` which inherits from ` __`SVG.Container`__

There are `linear` and `radial` gradients. The `linear` gradient can be created like this:

```javascript
var gradient = draw.gradient('linear', function(stop) {
  stop.at(0, '#333')
  stop.at(1, '#fff')
})
```

Finally, to use the gradient on an element:

```javascript
rect.attr({ fill: gradient })
```

Or:

```javascript
rect.fill(gradient)
```

By passing the gradient instance as the fill on any element, the `fill()` method will be called on the gradient instance.

<iframe width="100%" height="205" src="//jsfiddle.net/wout/25bzorm3/2/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

(link:https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Gradients text: MDN target: _blank) has a great example page on how SVG Gradients work.

## <span class="subject">gradient.</span>at()

`returns` __`itself`__

The `offset` and `color` parameters are required for stops, `opacity` is optional. The offset is a float between `0` and `1`, or a percentage value (e.g. `33%`).

```javascript
stop.at(0, '#333')
```

or

```javascript
stop.at({ offset: 0, color: '#333', opacity: 1 })
```

## <span class="subject">gradient.</span>fill()

`returns` __`string`__

```javascript
gradient.fill() //-> returns 'url(#SvgjsGradient1234)'
```

## <span class="subject">gradient.</span>from()

`returns` __`itself`__<br>`animate` __`yes`__

To define the direction you can set from `x`, `y` and to `x`, `y`:

```javascript
gradient.from(0, 0).to(0, 1)
```

The from and to values are also expressed in percent.

## <span class="subject">gradient.</span>get()

`returns` __`SVG.Stop`__

The `get()` method makes it even easier to get a stop from an existing gradient:

```javascript
var gradient = draw.gradient('radial', function(stop) {
  stop.at({ offset: 0, color: '#000', opacity: 1 })   // -> first
  stop.at({ offset: 0.5, color: '#f03', opacity: 1 }) // -> second
  stop.at({ offset: 1, color: '#066', opacity: 1 })   // -> third
})

var s1 = gradient.get(0) // -> returns "first" stop
```

## <span class="subject">gradient.</span>radius()

`returns` __`itself`__<br>`animate` __`yes`__

Radial gradients have a `radius()` method to define the outermost radius to where the inner color should develop:

```javascript
var gradient = draw.gradient('radial', function(stop) {
  stop.at(0, '#333')
  stop.at(1, '#fff')
})

gradient.from(0.5, 0.5).to(0.5, 0.5).radius(0.5)
```

## <span class="subject">gradient.</span>to()

`returns` __`itself`__<br>`animate` __`yes`__

To define the direction you can set from `x`, `y` and to `x`, `y`:

```javascript
gradient.from(0, 0).to(0, 1)
```

The from and to values are also expressed in percent.

## <span class="subject">gradient.</span>update()

`returns` __`itself`__

A gradient can also be updated afterwards:

```javascript
gradient.update(function(stop) {
  stop.at(0.1, '#333', 0.2)
  stop.at(0.9, '#f03', 1)
})
```

And even a single stop can be updated:

```javascript
var s1, s2, s3

draw.gradient('radial', function(stop) {
  s1 = stop.at(0, '#000')
  s2 = stop.at(0.5, '#f03')
  s3 = stop.at(1, '#066')
})

s1.update(0.1, '#0f0', 1)
```

<br>
# SVG.Stop

## at() <span class="suffix">constructor</span>

`constructor on` __`SVG.Gradient`__
`returns` __`SVG.Stop`__ ` which inherits from ` __`SVG.Element`__

The stop elements are only available inside gradient elements.

```javascript
var stop = gradient.at(0.5, '#f03')
```

or

```javascript
var stop = gradient.at({ offset: 0.5, color: '#f06', opacity: 1 })
```

## <span class="subject">stop.</span>update()

`returns` __`itself`__

Takes the same parameters as the constructor.

```javascript
stop.update(0, '#333')
```

or

```javascript
stop.update({ offset: 0, color: '#333', opacity: 1 })
```

<br>
# SVG.Pattern

## pattern() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Pattern`__ ` which inherits from ` __`SVG.Container`__

Creating a pattern is very similar to creating gradients:

```javascript
var pattern = draw.pattern(20, 20, function(add) {
  add.rect(20,20).fill('#f06')
  add.rect(10,10)
  add.rect(10,10).move(10,10)
})
```

This creates a checkered pattern of 20 x 20 pixels. You can add any available element to your pattern.

Finally, to use the pattern on an element:

```javascript
rect.attr({ fill: pattern })
```

Or:

```javascript
rect.fill(pattern)
```

By passing the pattern instance as the fill on any element, the `fill()` method will be called on the pattern instance.

<iframe width="100%" height="205" src="//jsfiddle.net/wout/jckwhha7/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## <span class="subject">pattern.</span>fill()

`returns` __`string`__

```javascript
pattern.fill() //-> returns 'url(#SvgjsPattern1234)'
```

## <span class="subject">pattern.</span>update()

`returns` __`itself`__

A pattern can also be updated afterwards:

```javascript
pattern.update(function(add) {
  add.circle(15).center(10,10)
})
```

<br>
# SVG.Mask

## mask() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Mask`__ ` which inherits from ` __`SVG.Container`__

```javascript
var ellipse = draw.ellipse(80, 40).move(10, 10).fill('#fff')

var mask = draw.mask().add(ellipse)

rect.maskWith(mask)
```

But you can also use multiple elements:

```javascript
var ellipse = draw.ellipse(80, 40).move(10, 10).fill({ color: '#fff' })
var text = draw.text('SVG.JS').move(10, 10).font({ size: 36 }).fill({ color: '#fff' })

var mask = draw.mask().add(text).add(ellipse)

rect.maskWith(mask)
```

<iframe width="100%" height="205" src="//jsfiddle.net/wout/s5mb5zds/1/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## maskWith()

`constructor on` __`SVG.Element`__
`returns` __`itself`__

The easiest way to mask is to use a single element:

```javascript
var ellipse = draw.ellipse(80, 40).move(10, 10).fill({ color: '#fff' })

rect.maskWith(ellipse)
```

If you want the masked object to be rendered at 100% you need to set the fill color of the masking object to white. But you might also want to use a gradient:

```javascript
var gradient = draw.gradient('linear', function(stop) {
  stop.at({ offset: 0, color: '#000' })
  stop.at({ offset: 1, color: '#fff' })
})

var ellipse = draw.ellipse(80, 40).move(10, 10).fill({ color: gradient })

rect.maskWith(ellipse)
```

## <span class="subject">mask.</span>unmask()

`returns` __`itself`__

Unmasking the elements can be done with the `unmask()` method:

```javascript
rect.unmask()
```

The `unmask()` method returns the masking element.

## <span class="subject">mask.</span>remove()

`returns` __`itself`__

Removing the mask altogether will also `unmask()` all masked elements as well:

```javascript
mask.remove()
```

## masker

`returns` __`SVG.Mask`__

For your convenience, the masking element is also referenced in the masked element. This can be useful in case you want to change the mask:

```javascript
rect.masker.fill('#fff')
```

<br>
# SVG.ClipPath

Clipping elements works exactly the same as masking elements. The only difference is that clipped elements will adopt the geometry of the clipping element. Therefore events are only triggered when entering the clipping element whereas with masks the masked element triggers the event. Another difference is that masks can define opacity with their fill colour and clipPaths can't.

## clip() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.ClipPath`__ ` which inherits from ` __`SVG.Container`__

Clip with multiple elements:

```javascript
var ellipse = draw.ellipse(80, 40).move(10, 10)
var text = draw.text('SVG.JS').move(10, 10).font({ size: 36 })

var clip = draw.clip().add(text).add(ellipse)

rect.clipWith(clip)
```

<iframe width="100%" height="205" src="//jsfiddle.net/wout/6g9pfr2m/1/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## clipWith()

`returns` __`itself`__

```javascript
var ellipse = draw.ellipse(80, 40).move(10, 10)

rect.clipWith(ellipse)
```

## <span class="subject">clipPath.</span>unclip()

`returns` __`itself`__

Unclipping the elements can be done with the `unclip()` method:

```javascript
rect.unclip()
```

## <span class="subject">clipPath.</span>remove()

`returns` __`itself`__

Removing the clip alltogether will also `unclip()` all clipped elements as well:

```javascript
clip.remove()
```

## clipper

`returns` __`SVG.ClipPath`__

For your convenience, the clipping element is also referenced in the clipped element. This can be useful in case you want to change the clipPath:

```javascript
rect.clipper.move(10, 10)
```

<br>
# SVG.Use

## use() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Use`__ ` which inherits from ` __`SVG.Shape`__

The use element simply emulates another existing element. Any changes on the master element will be reflected on all the `use` instances. The usage of `use()` is very straightforward:

```javascript
var rect = draw.rect(100, 100).fill('#f09')
var use  = draw.use(rect).move(200, 200)
```

In the case of the example above two rects will appear on the svg drawing, the original and the `use` instance. In some cases, you might want to hide the original element. The best way to do this is to create the original element in the defs node:

```javascript
var rect = draw.defs().rect(100, 100).fill('#f09')
var use  = draw.use(rect).move(200, 200)
```

In this way, the rect element acts as a library element. You can edit it, but it won't be rendered.

Another way is to point an external SVG file, just specified the element `id` and path to file.

```javascript
var use  = draw.use('elementId', 'path/to/file.svg')
```

This way is useful when you have complex images already created.
Note that, for external images (outside your domain) it may be necessary to load the file with XHR.

<br>
# SVG.Marker

## marker() <span class="suffix">constructor</span>

`constructor on` __`SVG.Container`__
`returns` __`SVG.Marker`__ ` which inherits from ` __`SVG.Container`__

Markers can be added to every individual point of a `line`, `polyline`, `polygon` and `path`. There are three types of markers: `start`, `mid` and `end`. Where `start` represents the first point, `end` the last and `mid` every point in between.

```javascript
var path = draw.path('M0 0 A50 50 0 0 1 50 50 A50 50 0 0 0 100 100')

path.fill('none').move(20, 20).stroke({ width: 1, color: '#ccc' })

path.marker('start', 10, 10, function(add) {
  add.circle(10).fill('#f06')
})
path.marker('mid', 10, 10, function(add) {
  add.rect(5, 10).cx(5).fill('#ccc')
})
path.marker('end', 20, 20, function(add) {
  add.circle(6).center(4, 5)
  add.circle(6).center(4, 15)
  add.circle(6).center(12, 10)

  this.fill('#0f9')
})
```

The `marker()` method can be used in three ways. Firstly, a marker can be created on any container element (e.g. svg, nested, group, ...). This is useful if you plan to reuse the marker many times, so it will create a marker in the defs but not show it yet:

```javascript
var marker = draw.marker(10, 10, function(add) {
  add.rect(10, 10)
})
```

Secondly a marker can be created and applied directly on its target element:

```javascript
path.marker('start', 10, 10, function(add) {
  add.circle(10).fill('#f06')
})
```

This will create a marker in the defs and apply it directly. Note that the first argument defines the position of the marker and that there are four arguments as opposed to three with the first example.

Lastly, if a marker is created for reuse on a container element, it can be applied directly to the target element:

```javascript
path.marker('mid', marker)
```

Finally, to get a marker instance from the target element reference:

```javascript
path.reference('marker-end')
```

<iframe width="100%" height="205" src="//jsfiddle.net/wout/j3fr5okk/embedded/result,js/?accentColor=f06" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## <span class="subject">marker.</span>height()

`returns` __`itself`__<br>`animate` __`yes`__

Defines the `markerHeight` attribute:

```javascript
marker.height(10)
```

## <span class="subject">marker.</span>ref()

`returns` __`itself`__

By default, the `refX` and `refY` attributes of a marker are set to respectively half the `width` nd `height` values. To define the `refX` and `refY` of a marker differently:

```javascript
marker.ref(2, 7)
```

## <span class="subject">marker.</span>size()

`returns` __`itself`__<br>`animate` __`yes`__

Defines the `markerWidth` and `markerHeight` attributes:

```javascript
marker.size(10, 10)
```

## <span class="subject">marker.</span>update()

`returns` __`itself`__

Updating the contents of a marker will `clear()` the existing content and add the content defined in the block passed as the first argument:

```javascript
marker.update(function(add) {
  add.circle(10)
})
```

## <span class="subject">marker.</span>width()

`returns` __`itself`__<br>`animate` __`yes`__

Defines the `markerWidth` attribute:

```javascript
marker.width(10)
```

<br>
# SVG.Bare

For all SVG elements that are not described by SVG.js, the `SVG.Bare` class comes in handy. This class inherits directly from `SVG.Element` and makes it possible to add custom methods in a separate namespace without polluting the main `SVG.Element` namespace. Consider it your personal playground.

## element() <span class="suffix">constructor</span>

`returns` __`SVG.Bare`__ ` which inherits from ` __`SVG.Element`__

The `SVG.Bare` class can be instantiated with the `element()` method on any parent element:

```javascript
var element = draw.element('title')
```
The string value passed as the first argument is the node name that should be generated.

Additionally, any existing class name can be passed as the second argument to define from which class the element should inherit:

```javascript
var element = draw.element('symbol', SVG.Parent)
```

This gives you as the user a lot of power. But remember, with great power comes great responsibility.

## <span class="subject">element.</span>words()

`returns` __`itself`__

The `SVG.Bare` instance carries an additional method to add plain text:

```javascript
var element = draw.element('title').words('This is a title.')
//-> <title>This is a title.</title>
```

----

Description: SVG.Element is the base prototype wrapping all elements (or nodes for that matter) in SVG.js. An extra level of refinement is added with SVG.Shape.