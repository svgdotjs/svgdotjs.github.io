Title: Position

----

Text: 

# Position

While positioning an element by directly setting its attributes works only if the attributes are used natively by that type of element, the positioning methods described below are much more convenient as they work for all element types.

For example, the following code works because each element is positioned by setting native attributes:

```javascript
rect.attr({ x: 20, y: 60 })
circle.attr({ cx: 50, cy: 40 })
```

The `rect` will be moved by its upper left corner to the new coordinates, and the `circle` will be moved by its center. However, trying to move a `circle` by its 'corner' or a `rect` by its center in this way will fail. The following lines will get silently ignored as the attributes that are addressed are not natively used by the element setting them:

```javascript
rect.attr({ cx: 20, cy: 60 })
circle.attr({ x: 50, y: 40 })
```

However, the positioning methods detailed below will work for all element types, regardless of whether the attributes being addressed are native to the type. So, unlike the lines above, these lines work just fine:

```javascript
rect.cx(20).cy(60)
circle.x(50).y(40)
```

It is important to note, though, that these methods are only intended for use with user (unitless) coordinates. If, for example, an element has its size set via percentages or other units, the positioning methods that address its native attributes will most likely still work, but the ones that address non-native attributes will give unexpected results -- as both getters and setters!

## move()

`returns` __`itself`__

Move the element by its upper left corner to a given `x` and `y` position:

```javascript
rect.move(200, 350)
```

## x() _as getter_

`returns` __`value`__

Without an argument the `x()` method serves as a getter:

```javascript
var x = rect.x()
```

## x() _as setter_

`returns` __`itself`__

Move the element by its upper left corner along the x-axis only:

```javascript
rect.x(200)
```

## y() _as getter_

`returns` __`value`__

Without an argument the `y()` method serves as a getter:

```javascript
var y = rect.y()
```

## y() _as setter_

`returns` __`itself`__

Move the element by its upper left corner along the y-axis only:

```javascript
rect.y(350)
```

## center()

`returns` __`itself`__

Move the element by its center to a given `cx` and `cy` position:

```javascript
rect.center(150, 150)
```

## cx() _as getter_

`returns` __`value`__

Without an argument the `cx()` method serves as a getter:

```javascript
var cx = rect.cx()
```

## cx() _as setter_

`returns` __`itself`__

Move the element by its center in the `x` direction only:

```javascript
rect.cx(200)
```

## cy() _as getter_

`returns` __`value`__

Without an argument the `cy()` method serves as a getter as well:

```javascript
var cy = rect.cy()
```

## cy() _as setter_

`returns` __`itself`__

Move the element by its center in the `y` direction only:

```javascript
rect.cy(350)
```

## dmove()

`returns` __`itself`__

Shift the element in both the `x` and `y` directions relative to its current position:

```javascript
rect.dmove(10, 30)
```

## dx()

`returns` __`itself`__

Shift the element in the `x` direction relative to its current position:

```javascript
rect.dx(200)
```

## dy()

`returns` __`itself`__

Shift the element in the `y` direction relative to its current position:

```javascript
rect.dy(200)
```